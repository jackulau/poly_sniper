//! Execution Algorithms
//!
//! TWAP and VWAP execution algorithms for breaking large orders into
//! smaller chunks to reduce market impact and slippage.

mod twap;
mod vwap;

pub use twap::{TwapConfig, TwapExecutor, TwapState};
pub use vwap::{VolumeProfile, VwapConfig, VwapExecutor, VwapState};

use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};

/// A child order generated by an execution algorithm
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChildOrder {
    /// Unique ID for this child order
    pub id: String,
    /// Parent order/signal ID
    pub parent_id: String,
    /// Slice number (0-indexed)
    pub slice_index: u32,
    /// Market ID
    pub market_id: String,
    /// Token ID
    pub token_id: String,
    /// Order side
    pub side: polysniper_core::Side,
    /// Target price (may be adjusted based on market conditions)
    pub price: Option<Decimal>,
    /// Size for this child order
    pub size: Decimal,
    /// Scheduled execution time
    pub scheduled_at: DateTime<Utc>,
    /// Whether this order has been submitted
    pub submitted: bool,
    /// Actual submission time
    pub submitted_at: Option<DateTime<Utc>>,
    /// Fill status
    pub filled_size: Decimal,
    /// Average fill price
    pub avg_fill_price: Option<Decimal>,
}

impl ChildOrder {
    /// Check if the order is fully filled
    pub fn is_filled(&self) -> bool {
        self.filled_size >= self.size
    }

    /// Get remaining size to fill
    pub fn remaining_size(&self) -> Decimal {
        self.size - self.filled_size
    }
}

/// Execution statistics for a parent order
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionStats {
    /// Parent order/signal ID
    pub parent_id: String,
    /// Algorithm used (TWAP/VWAP)
    pub algorithm: String,
    /// Total target size
    pub total_size: Decimal,
    /// Size executed so far
    pub executed_size: Decimal,
    /// Remaining size to execute
    pub remaining_size: Decimal,
    /// Number of child order fills
    pub num_fills: u32,
    /// Total number of slices
    pub total_slices: u32,
    /// Number of slices completed
    pub completed_slices: u32,
    /// Simple average fill price
    pub avg_fill_price: Decimal,
    /// Volume-weighted average fill price
    pub vwap: Decimal,
    /// Initial/reference price when execution started
    pub reference_price: Decimal,
    /// Slippage percentage vs reference price
    pub slippage_pct: Decimal,
    /// When execution started
    pub started_at: DateTime<Utc>,
    /// Estimated completion time
    pub estimated_completion: DateTime<Utc>,
    /// Actual completion time (if complete)
    pub completed_at: Option<DateTime<Utc>>,
}

impl ExecutionStats {
    /// Check if execution is complete
    pub fn is_complete(&self) -> bool {
        self.remaining_size <= Decimal::ZERO
    }

    /// Get execution progress as percentage (0-100)
    pub fn progress_pct(&self) -> Decimal {
        if self.total_size.is_zero() {
            return Decimal::ONE_HUNDRED;
        }
        (self.executed_size / self.total_size) * Decimal::ONE_HUNDRED
    }
}

/// Configuration for execution algorithms
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlgorithmConfig {
    /// Default algorithm to use for large orders
    pub default_algorithm: AlgorithmType,
    /// Minimum order size (USD) to trigger algorithmic execution
    pub min_size_for_algo: Decimal,
    /// TWAP-specific configuration
    pub twap: TwapConfig,
    /// VWAP-specific configuration
    pub vwap: VwapConfig,
}

impl Default for AlgorithmConfig {
    fn default() -> Self {
        Self {
            default_algorithm: AlgorithmType::Twap,
            min_size_for_algo: Decimal::new(100, 0), // $100 minimum for algo execution
            twap: TwapConfig::default(),
            vwap: VwapConfig::default(),
        }
    }
}

/// Type of execution algorithm
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum AlgorithmType {
    /// Time-Weighted Average Price
    Twap,
    /// Volume-Weighted Average Price
    Vwap,
}

impl std::fmt::Display for AlgorithmType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AlgorithmType::Twap => write!(f, "TWAP"),
            AlgorithmType::Vwap => write!(f, "VWAP"),
        }
    }
}
