use crate::resolution::ResolutionConfig;
use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use std::fmt;

/// Unique identifier for a market (Polymarket condition ID)
pub type MarketId = String;

/// Unique identifier for a token (YES/NO outcome token)
pub type TokenId = String;

/// Unique identifier for an order
pub type OrderId = String;

/// Side of a trade
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "UPPERCASE")]
pub enum Side {
    Buy,
    Sell,
}

impl fmt::Display for Side {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Side::Buy => write!(f, "BUY"),
            Side::Sell => write!(f, "SELL"),
        }
    }
}

/// Order type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "UPPERCASE")]
pub enum OrderType {
    /// Good-til-cancelled limit order
    Gtc,
    /// Fill-or-kill market order
    Fok,
    /// Good-til-date limit order
    Gtd,
}

/// Outcome type for a market
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Outcome {
    Yes,
    No,
}

impl fmt::Display for Outcome {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Outcome::Yes => write!(f, "YES"),
            Outcome::No => write!(f, "NO"),
        }
    }
}

/// Priority level for trade signals
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum Priority {
    Low = 0,
    #[default]
    Normal = 1,
    High = 2,
    Critical = 3,
}

/// Market metadata from Gamma API
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Market {
    /// Condition ID (unique market identifier)
    pub condition_id: MarketId,
    /// Human-readable question
    pub question: String,
    /// Market description
    pub description: Option<String>,
    /// Market category/tags
    pub tags: Vec<String>,
    /// YES token ID
    pub yes_token_id: TokenId,
    /// NO token ID
    pub no_token_id: TokenId,
    /// When the market was created
    pub created_at: DateTime<Utc>,
    /// When the market ends (resolution time)
    pub end_date: Option<DateTime<Utc>>,
    /// Whether the market is active for trading
    pub active: bool,
    /// Whether the market is closed
    pub closed: bool,
    /// Total volume in USD
    pub volume: Decimal,
    /// Total liquidity in USD
    pub liquidity: Decimal,
}

/// A single price level in the orderbook
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PriceLevel {
    pub price: Decimal,
    pub size: Decimal,
}

/// Orderbook snapshot for a token
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Orderbook {
    pub token_id: TokenId,
    pub market_id: MarketId,
    pub bids: Vec<PriceLevel>,
    pub asks: Vec<PriceLevel>,
    pub timestamp: DateTime<Utc>,
}

impl Orderbook {
    /// Get the best bid price
    pub fn best_bid(&self) -> Option<Decimal> {
        self.bids.first().map(|l| l.price)
    }

    /// Get the best ask price
    pub fn best_ask(&self) -> Option<Decimal> {
        self.asks.first().map(|l| l.price)
    }

    /// Get the mid price
    pub fn mid_price(&self) -> Option<Decimal> {
        match (self.best_bid(), self.best_ask()) {
            (Some(bid), Some(ask)) => Some((bid + ask) / Decimal::TWO),
            (Some(bid), None) => Some(bid),
            (None, Some(ask)) => Some(ask),
            (None, None) => None,
        }
    }

    /// Get the spread
    pub fn spread(&self) -> Option<Decimal> {
        match (self.best_bid(), self.best_ask()) {
            (Some(bid), Some(ask)) => Some(ask - bid),
            _ => None,
        }
    }
}

/// Trade signal generated by a strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradeSignal {
    /// Unique signal ID
    pub id: String,
    /// Strategy that generated this signal
    pub strategy_id: String,
    /// Market to trade
    pub market_id: MarketId,
    /// Token to trade
    pub token_id: TokenId,
    /// Outcome being traded
    pub outcome: Outcome,
    /// Buy or sell
    pub side: Side,
    /// Target price (for limit orders)
    pub price: Option<Decimal>,
    /// Size in contracts
    pub size: Decimal,
    /// Size in USD
    pub size_usd: Decimal,
    /// Order type
    pub order_type: OrderType,
    /// Priority level
    pub priority: Priority,
    /// When the signal was generated
    pub timestamp: DateTime<Utc>,
    /// Reason/explanation for the signal
    pub reason: String,
    /// Additional metadata
    pub metadata: serde_json::Value,
}

/// Order to be submitted to CLOB
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Order {
    pub id: OrderId,
    pub market_id: MarketId,
    pub token_id: TokenId,
    pub side: Side,
    pub price: Decimal,
    pub size: Decimal,
    pub order_type: OrderType,
    pub signal_id: String,
    pub created_at: DateTime<Utc>,
}

/// Order status from CLOB
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum OrderStatus {
    Live,
    Matched,
    Cancelled,
    Expired,
}

/// Position in a market
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Position {
    pub market_id: MarketId,
    pub token_id: TokenId,
    pub outcome: Outcome,
    pub size: Decimal,
    pub avg_price: Decimal,
    pub realized_pnl: Decimal,
    pub unrealized_pnl: Decimal,
    pub updated_at: DateTime<Utc>,
}

/// Price snapshot for a market
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PriceSnapshot {
    pub market_id: MarketId,
    pub token_id: TokenId,
    pub price: Decimal,
    pub timestamp: DateTime<Utc>,
}

/// Configuration for endpoints
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EndpointConfig {
    pub clob_rest: String,
    pub clob_ws: String,
    pub gamma_api: String,
}

impl Default for EndpointConfig {
    fn default() -> Self {
        Self {
            clob_rest: "https://clob.polymarket.com".to_string(),
            clob_ws: "wss://ws-subscriptions-clob.polymarket.com/ws/".to_string(),
            gamma_api: "https://gamma-api.polymarket.com".to_string(),
        }
    }
}

/// Authentication configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthConfig {
    /// Environment variable containing the private key
    pub private_key_env: String,
    /// Signature type (0 = EOA, 1 = Poly Proxy, 2 = Poly Gnosis Safe)
    pub signature_type: u8,
}

impl Default for AuthConfig {
    fn default() -> Self {
        Self {
            private_key_env: "POLYMARKET_PRIVATE_KEY".to_string(),
            signature_type: 0,
        }
    }
}

/// Kelly criterion position sizing configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KellyConfig {
    /// Whether Kelly criterion sizing is enabled
    pub enabled: bool,
    /// Fractional Kelly multiplier (0.25 = quarter-Kelly, 0.5 = half-Kelly, 1.0 = full Kelly)
    /// Lower values are more conservative
    pub fraction: Decimal,
    /// Number of recent trades to consider for edge calculation
    pub window_size: u32,
    /// Minimum number of trades required before Kelly sizing kicks in
    /// Uses base sizing until this threshold is met
    pub min_trades: u32,
    /// Maximum position multiplier (caps Kelly sizing to avoid over-betting)
    pub max_multiplier: Decimal,
    /// Minimum position multiplier (ensures some position even with negative edge)
    pub min_multiplier: Decimal,
}

impl Default for KellyConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            fraction: Decimal::new(5, 1),         // 0.5 (half-Kelly, conservative default)
            window_size: 100,                      // Last 100 trades
            min_trades: 20,                        // Need 20 trades before Kelly kicks in
            max_multiplier: Decimal::new(2, 0),    // 2.0 max (double size)
            min_multiplier: Decimal::new(25, 2),   // 0.25 min (quarter size)
        }
    }
}

/// Volatility-adjusted position sizing configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VolatilityConfig {
    /// Whether volatility-based sizing is enabled
    pub enabled: bool,
    /// Rolling window in seconds for volatility calculation
    pub window_secs: u64,
    /// Reference/baseline volatility percentage (standard deviation)
    pub base_volatility_pct: Decimal,
    /// Minimum size multiplier floor (e.g., 0.25 = 25% of normal size)
    pub min_size_multiplier: Decimal,
    /// Maximum size multiplier ceiling (e.g., 1.5 = 150% of normal size)
    pub max_size_multiplier: Decimal,
}

impl Default for VolatilityConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            window_secs: 300,
            base_volatility_pct: Decimal::new(5, 0),  // 5%
            min_size_multiplier: Decimal::new(25, 2), // 0.25
            max_size_multiplier: Decimal::new(15, 1), // 1.5
        }
    }
}

/// Drawdown-triggered position scaling configuration
///
/// Progressively reduces position sizes as portfolio drawdown deepens,
/// providing smooth risk reduction rather than binary halt/resume.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DrawdownConfig {
    /// Whether drawdown-based scaling is enabled
    pub enabled: bool,
    /// Tier 1 threshold: drawdown percentage at which first reduction begins (e.g., 5.0 = 5%)
    pub tier_1_threshold_pct: Decimal,
    /// Tier 1 multiplier: size factor at tier 1 threshold (e.g., 0.75 = 75% of normal)
    pub tier_1_multiplier: Decimal,
    /// Tier 2 threshold: drawdown percentage for second tier (e.g., 10.0 = 10%)
    pub tier_2_threshold_pct: Decimal,
    /// Tier 2 multiplier: size factor at tier 2 threshold (e.g., 0.50 = 50% of normal)
    pub tier_2_multiplier: Decimal,
    /// Tier 3 threshold: drawdown percentage for third tier (e.g., 20.0 = 20%)
    pub tier_3_threshold_pct: Decimal,
    /// Tier 3 multiplier: size factor at tier 3 threshold (e.g., 0.25 = 25% of normal)
    pub tier_3_multiplier: Decimal,
    /// Maximum drawdown percentage before minimum sizing or halt (e.g., 30.0 = 30%)
    pub max_drawdown_pct: Decimal,
    /// Minimum size multiplier floor (e.g., 0.10 = 10% of normal size)
    pub min_multiplier: Decimal,
    /// Recovery buffer: percentage below current drawdown level before increasing sizes again
    /// This provides hysteresis to prevent rapid oscillation during volatile recovery periods
    pub recovery_buffer_pct: Decimal,
}

impl Default for DrawdownConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            tier_1_threshold_pct: Decimal::new(5, 0),   // 5%
            tier_1_multiplier: Decimal::new(75, 2),    // 0.75
            tier_2_threshold_pct: Decimal::new(10, 0),  // 10%
            tier_2_multiplier: Decimal::new(50, 2),    // 0.50
            tier_3_threshold_pct: Decimal::new(20, 0),  // 20%
            tier_3_multiplier: Decimal::new(25, 2),    // 0.25
            max_drawdown_pct: Decimal::new(30, 0),      // 30%
            min_multiplier: Decimal::new(10, 2),       // 0.10
            recovery_buffer_pct: Decimal::new(2, 0),    // 2%
        }
    }
}

/// Action to take when a time-based rule is triggered
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TimeRuleAction {
    /// Reduce position size by a multiplier (0.0 - 1.0)
    ReduceSize { multiplier: Decimal },
    /// Block new positions but allow exits
    BlockNew,
    /// Halt all trading on the market
    HaltAll,
}

/// A single time-based risk rule
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimeRule {
    /// Rule name for identification and logging
    pub name: String,
    /// Hours before event/resolution when rule activates
    pub hours_before: u64,
    /// Action to take when rule matches
    pub action: TimeRuleAction,
    /// Market patterns to match (glob patterns like "*", "election*", etc.)
    pub applies_to: Vec<String>,
}

/// Configuration for time-based risk rules
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimeRulesConfig {
    /// Whether time rules are enabled
    pub enabled: bool,
    /// List of time-based rules (evaluated in order, most restrictive wins)
    #[serde(default)]
    pub rules: Vec<TimeRule>,
}

impl Default for TimeRulesConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            rules: vec![
                TimeRule {
                    name: "pre_resolution_reduction".to_string(),
                    hours_before: 24,
                    action: TimeRuleAction::ReduceSize {
                        multiplier: Decimal::new(5, 1), // 0.5
                    },
                    applies_to: vec!["*".to_string()],
                },
                TimeRule {
                    name: "resolution_block".to_string(),
                    hours_before: 2,
                    action: TimeRuleAction::BlockNew,
                    applies_to: vec!["*".to_string()],
                },
            ],
        }
    }
}

/// Manual correlation group configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CorrelationGroupConfig {
    /// Group name/identifier
    pub name: String,
    /// Market IDs or slug patterns in this group
    pub markets: Vec<String>,
}

/// Correlation regime (market stress level)
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum CorrelationRegime {
    /// Normal market conditions - correlations at baseline levels
    #[default]
    Normal,
    /// Elevated correlations - increased market stress
    Elevated,
    /// Crisis conditions - correlations at extreme levels
    Crisis,
}

impl fmt::Display for CorrelationRegime {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CorrelationRegime::Normal => write!(f, "Normal"),
            CorrelationRegime::Elevated => write!(f, "Elevated"),
            CorrelationRegime::Crisis => write!(f, "Crisis"),
        }
    }
}

/// Configuration for correlation regime detection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CorrelationRegimeConfig {
    /// Whether regime detection is enabled
    pub enabled: bool,
    /// Short-term rolling window in seconds (default 300 - 5 min)
    pub short_window_secs: u64,
    /// Long-term rolling window in seconds (default 86400 - 24 hours)
    pub long_window_secs: u64,
    /// Threshold for elevated regime (z-score or fraction above baseline)
    /// Default 0.5 means 50% above the long-term average triggers elevated
    pub elevated_threshold: Decimal,
    /// Threshold for crisis regime (z-score or fraction above baseline)
    /// Default 1.0 means 100% above the long-term average triggers crisis
    pub crisis_threshold: Decimal,
    /// Exposure limit multiplier during normal regime (default 1.0)
    pub normal_limit_multiplier: Decimal,
    /// Exposure limit multiplier during elevated regime (default 0.7)
    pub elevated_limit_multiplier: Decimal,
    /// Exposure limit multiplier during crisis regime (default 0.4)
    pub crisis_limit_multiplier: Decimal,
    /// Minimum samples required before regime detection activates
    pub min_samples: usize,
    /// Hysteresis factor to prevent regime flickering (0.0-1.0)
    /// Correlation must drop by this factor below threshold to downgrade regime
    pub hysteresis_factor: Decimal,
}

impl Default for CorrelationRegimeConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            short_window_secs: 300,      // 5 minutes
            long_window_secs: 86400,     // 24 hours
            elevated_threshold: Decimal::new(5, 1),  // 0.5 (50% above baseline)
            crisis_threshold: Decimal::ONE,          // 1.0 (100% above baseline)
            normal_limit_multiplier: Decimal::ONE,
            elevated_limit_multiplier: Decimal::new(7, 1),  // 0.7
            crisis_limit_multiplier: Decimal::new(4, 1),    // 0.4
            min_samples: 100,
            hysteresis_factor: Decimal::new(1, 1),  // 0.1 (10%)
        }
    }
}

/// Correlation-aware position limit configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CorrelationConfig {
    /// Whether correlation-aware limits are enabled
    pub enabled: bool,
    /// Minimum correlation threshold to group markets (e.g., 0.7)
    pub correlation_threshold: Decimal,
    /// Time window in seconds for correlation calculation
    pub window_secs: u64,
    /// Maximum total exposure across correlated markets in USD
    pub max_correlated_exposure_usd: Decimal,
    /// Manual correlation groups (market slugs)
    #[serde(default)]
    pub groups: Vec<CorrelationGroupConfig>,
    /// Correlation regime detection configuration
    #[serde(default)]
    pub regime: CorrelationRegimeConfig,
}

impl Default for CorrelationConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            correlation_threshold: Decimal::new(7, 1), // 0.7
            window_secs: 3600,                         // 1 hour
            max_correlated_exposure_usd: Decimal::new(3000, 0),
            groups: Vec::new(),
            regime: CorrelationRegimeConfig::default(),
        }
    }
}

/// Control server configuration for emergency kill switch
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ControlConfig {
    /// Whether the control server is enabled
    pub enabled: bool,
    /// Port for the HTTP control server
    pub port: u16,
    /// Host address to bind to
    pub host: String,
    /// Optional bearer token for authentication
    pub auth_token: Option<String>,
    /// Enable Unix signal handlers (SIGUSR1/SIGUSR2)
    pub signal_handlers: bool,
}

impl Default for ControlConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            port: 9876,
            host: "127.0.0.1".to_string(),
            auth_token: None,
            signal_handlers: true,
        }
    }
}

/// VaR calculation method
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum VaRMethod {
    /// Historical VaR using percentile of actual returns
    Historical,
    /// Parametric VaR assuming normal distribution
    Parametric,
}

impl Default for VaRMethod {
    fn default() -> Self {
        VaRMethod::Historical
    }
}

/// Value at Risk (VaR) and Conditional VaR configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VaRConfig {
    /// Whether VaR-based risk limits are enabled
    pub enabled: bool,
    /// VaR calculation method
    pub method: VaRMethod,
    /// Confidence level for VaR (e.g., 0.95 for 95% VaR)
    pub confidence_level: Decimal,
    /// Number of days of historical data to use
    pub lookback_days: u32,
    /// Maximum allowed daily portfolio VaR in USD
    pub max_portfolio_var_usd: Decimal,
    /// Maximum position VaR contribution as percentage of total (e.g., 0.25 = 25%)
    pub max_position_var_contribution_pct: Decimal,
    /// Whether to use CVaR instead of VaR for limit enforcement
    pub use_cvar_for_limits: bool,
}

impl Default for VaRConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            method: VaRMethod::default(),
            confidence_level: Decimal::new(95, 2), // 0.95
            lookback_days: 30,
            max_portfolio_var_usd: Decimal::new(500, 0), // $500
            max_position_var_contribution_pct: Decimal::new(25, 2), // 0.25 (25%)
            use_cvar_for_limits: false,
        }
    }
}

/// VaR calculation result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VaRResult {
    /// 1-day Value at Risk in USD
    pub var_1d: Decimal,
    /// 1-day Conditional VaR (Expected Shortfall) in USD
    pub cvar_1d: Decimal,
    /// 10-day VaR scaled from 1-day (using sqrt(10) rule)
    pub var_10d: Decimal,
    /// VaR contribution per position (market_id -> contribution USD)
    pub position_contributions: std::collections::HashMap<MarketId, Decimal>,
    /// Confidence level used for calculation
    pub confidence_level: Decimal,
    /// Timestamp of calculation
    pub calculated_at: chrono::DateTime<chrono::Utc>,
}

impl Default for VaRResult {
    fn default() -> Self {
        Self {
            var_1d: Decimal::ZERO,
            cvar_1d: Decimal::ZERO,
            var_10d: Decimal::ZERO,
            position_contributions: std::collections::HashMap::new(),
            confidence_level: Decimal::new(95, 2),
            calculated_at: chrono::Utc::now(),
        }
    }
}

/// Risk configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RiskConfig {
    pub max_position_size_usd: Decimal,
    pub max_order_size_usd: Decimal,
    pub daily_loss_limit_usd: Decimal,
    pub circuit_breaker_loss_usd: Decimal,
    pub max_orders_per_minute: u32,
    /// Volatility-adjusted position sizing config
    #[serde(default)]
    pub volatility: VolatilityConfig,
    /// Kelly criterion position sizing config
    #[serde(default)]
    pub kelly: KellyConfig,
    /// Time-based risk rules config
    #[serde(default)]
    pub time_rules: TimeRulesConfig,
    /// Correlation-aware position limit configuration
    #[serde(default)]
    pub correlation: CorrelationConfig,
    /// Drawdown-triggered position scaling config
    #[serde(default)]
    pub drawdown: DrawdownConfig,
    /// Value at Risk configuration
    #[serde(default)]
    pub var: VaRConfig,
}

impl Default for RiskConfig {
    fn default() -> Self {
        Self {
            max_position_size_usd: Decimal::new(5000, 0),
            max_order_size_usd: Decimal::new(500, 0),
            daily_loss_limit_usd: Decimal::new(500, 0),
            circuit_breaker_loss_usd: Decimal::new(300, 0),
            max_orders_per_minute: 60,
            volatility: VolatilityConfig::default(),
            kelly: KellyConfig::default(),
            time_rules: TimeRulesConfig::default(),
            correlation: CorrelationConfig::default(),
            drawdown: DrawdownConfig::default(),
            var: VaRConfig::default(),
        }
    }
}

/// Shortfall tracking and adaptive execution configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShortfallConfig {
    /// Enable shortfall tracking
    pub enabled: bool,
    /// Shortfall threshold in basis points to trigger faster execution
    pub adverse_threshold_bps: Decimal,
    /// Shortfall threshold in basis points for favorable price movement
    pub favorable_threshold_bps: Decimal,
    /// Speed multiplier when experiencing adverse selection
    pub adverse_speed_multiplier: Decimal,
    /// Speed multiplier when price is favorable
    pub favorable_speed_multiplier: Decimal,
    /// Minimum speed multiplier (can't go slower than this)
    pub min_speed_multiplier: Decimal,
    /// Maximum speed multiplier (can't go faster than this)
    pub max_speed_multiplier: Decimal,
}

impl Default for ShortfallConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            adverse_threshold_bps: Decimal::new(20, 0),   // 20 bps
            favorable_threshold_bps: Decimal::new(10, 0), // 10 bps
            adverse_speed_multiplier: Decimal::new(15, 1), // 1.5x
            favorable_speed_multiplier: Decimal::new(7, 1), // 0.7x
            min_speed_multiplier: Decimal::new(5, 1),     // 0.5x
            max_speed_multiplier: Decimal::new(2, 0),     // 2.0x
        }
    }
}

/// Execution configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionConfig {
    pub dry_run: bool,
    pub max_retries: u32,
    pub retry_delay_ms: u64,
    #[serde(default)]
    pub queue_estimation: QueueEstimatorConfig,
    #[serde(default)]
    pub shortfall: ShortfallConfig,
}

impl Default for ExecutionConfig {
    fn default() -> Self {
        Self {
            dry_run: true,
            max_retries: 3,
            retry_delay_ms: 100,
            queue_estimation: QueueEstimatorConfig::default(),
            shortfall: ShortfallConfig::default(),
        }
    }
}

/// Configuration for queue position estimation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QueueEstimatorConfig {
    /// Whether queue estimation is enabled
    pub enabled: bool,
    /// How far back to look for fill rates (in seconds)
    pub history_window_secs: u64,
    /// Minimum fills needed for reliable estimation
    pub min_samples_for_estimate: u32,
    /// How quickly confidence decays with time (0.0 to 1.0)
    pub confidence_decay_factor: f64,
}

impl Default for QueueEstimatorConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            history_window_secs: 300,
            min_samples_for_estimate: 10,
            confidence_decay_factor: 0.95,
        }
    }
}

/// Queue position information for a limit order
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QueuePosition {
    /// Price level of the order
    pub price_level: Decimal,
    /// Total size ahead in the queue
    pub size_ahead: Decimal,
    /// Approximate position in queue
    pub estimated_position: u32,
    /// Estimated time to fill in seconds (None if insufficient data)
    pub estimated_time_to_fill_secs: Option<f64>,
    /// Confidence in the estimate (0.0 to 1.0)
    pub confidence: f64,
    /// Probability of fill in the next minute
    pub fill_probability_1min: f64,
    /// Probability of fill in the next 5 minutes
    pub fill_probability_5min: f64,
}

/// Configuration for price level analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PriceLevelConfig {
    /// How far back to track price level statistics (in seconds)
    pub history_window_secs: u64,
    /// Minimum number of touches required for valid statistics
    pub min_touches_for_stats: u32,
}

impl Default for PriceLevelConfig {
    fn default() -> Self {
        Self {
            history_window_secs: 3600, // 1 hour
            min_touches_for_stats: 5,
        }
    }
}

/// Persistence configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PersistenceConfig {
    pub enabled: bool,
    pub db_path: String,
    pub price_snapshot_interval_secs: u64,
    pub max_price_snapshots: i64,
}

impl Default for PersistenceConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            db_path: "data/polysniper.db".to_string(),
            price_snapshot_interval_secs: 60,
            max_price_snapshots: 10000,
        }
    }
}

/// Metrics configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetricsConfig {
    pub enabled: bool,
    pub port: u16,
    pub collection_interval_secs: u64,
}

impl Default for MetricsConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            port: 9090,
            collection_interval_secs: 60,
        }
    }
}

/// Health check server configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthConfig {
    pub enabled: bool,
    pub bind_address: String,
}

impl Default for HealthConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            bind_address: "127.0.0.1:8080".to_string(),
        }
    }
}

/// Slack alerting configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SlackAlertConfig {
    pub enabled: bool,
    pub webhook_url: String,
    pub channel: Option<String>,
    pub username: Option<String>,
    pub icon_emoji: Option<String>,
}

impl Default for SlackAlertConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            webhook_url: String::new(),
            channel: Some("#polysniper-alerts".to_string()),
            username: Some("Polysniper".to_string()),
            icon_emoji: Some(":chart_with_upwards_trend:".to_string()),
        }
    }
}

/// Telegram alerting configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TelegramAlertConfig {
    pub enabled: bool,
    pub bot_token: String,
    pub chat_id: String,
    pub parse_mode: Option<String>,
}

impl Default for TelegramAlertConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            bot_token: String::new(),
            chat_id: String::new(),
            parse_mode: Some("HTML".to_string()),
        }
    }
}

/// Discord webhook configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DiscordConfig {
    pub enabled: bool,
    /// Webhook URL (recommended to use DISCORD_WEBHOOK_URL env var instead)
    pub webhook_url: Option<String>,
    pub notify_on_trade: bool,
    pub notify_on_error: bool,
    pub notify_on_risk_events: bool,
    pub notify_on_connection_status: bool,
    pub dry_run: bool,
    pub rate_limit_per_minute: u32,
}

impl Default for DiscordConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            webhook_url: None,
            notify_on_trade: true,
            notify_on_error: true,
            notify_on_risk_events: true,
            notify_on_connection_status: false,
            dry_run: false,
            rate_limit_per_minute: 30,
        }
    }
}

/// Alerting configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertingConfig {
    pub enabled: bool,
    pub min_level: String,
    pub rate_limit_seconds: u64,
    pub slack: SlackAlertConfig,
    pub telegram: TelegramAlertConfig,
}

/// Fill management configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FillManagementConfig {
    pub enabled: bool,
    pub auto_resubmit: bool,
    pub min_resubmit_size: Decimal,
    pub poll_interval_ms: u64,
    pub max_resubmit_attempts: u32,
}

impl Default for FillManagementConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            auto_resubmit: false,
            min_resubmit_size: Decimal::new(10, 0),
            poll_interval_ms: 1000,
            max_resubmit_attempts: 3,
        }
    }
}

impl Default for AlertingConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            min_level: "warning".to_string(),
            rate_limit_seconds: 60,
            slack: SlackAlertConfig::default(),
            telegram: TelegramAlertConfig::default(),
        }
    }
}

/// Webhook server configuration for receiving ML predictions
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WebhookConfig {
    /// Whether the webhook server is enabled
    pub enabled: bool,
    /// Host to bind the server to
    pub host: String,
    /// Port to listen on
    pub port: u16,
    /// Optional API key for authentication (checked via X-API-Key header)
    pub api_key: Option<String>,
}

impl Default for WebhookConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            host: "127.0.0.1".to_string(),
            port: 8080,
            api_key: None,
        }
    }
}

/// Main application configuration
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct AppConfig {
    #[serde(default)]
    pub endpoints: EndpointConfig,
    #[serde(default)]
    pub auth: AuthConfig,
    #[serde(default)]
    pub risk: RiskConfig,
    #[serde(default)]
    pub execution: ExecutionConfig,
    #[serde(default)]
    pub persistence: PersistenceConfig,
    #[serde(default)]
    pub metrics: MetricsConfig,
    #[serde(default)]
    pub alerting: AlertingConfig,
    #[serde(default)]
    pub resolution: ResolutionConfig,
    #[serde(default)]
    pub control: ControlConfig,
    #[serde(default)]
    pub discord: DiscordConfig,
    #[serde(default)]
    pub gas: crate::GasConfig,
    #[serde(default)]
    pub webhook: WebhookConfig,
    #[serde(default)]
    pub connection: ConnectionConfig,
    #[serde(default)]
    pub health: HealthConfig,
}

/// Adaptive order sizing configuration based on orderbook depth
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AdaptiveSizingConfig {
    /// Whether adaptive sizing is enabled
    pub enabled: bool,
    /// Maximum market impact in basis points
    pub max_market_impact_bps: Decimal,
    /// Minimum ratio of order size to available liquidity
    pub min_liquidity_ratio: Decimal,
    /// Factor to reduce size when liquidity is low (0.0 - 1.0)
    pub size_reduction_factor: Decimal,
}

impl Default for AdaptiveSizingConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            max_market_impact_bps: Decimal::new(50, 0), // 50 bps
            min_liquidity_ratio: Decimal::new(1, 1),    // 0.1 (10%)
            size_reduction_factor: Decimal::new(5, 1),  // 0.5
        }
    }
}

/// Order type for exit orders
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ExitOrderType {
    /// Fill-or-kill market order
    #[default]
    Fok,
    /// Good-til-cancelled limit order
    Gtc,
    /// Market order (executed as FOK)
    Market,
}

/// Type of P&L floor for exit decisions
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum PnlFloorType {
    /// Absolute USD value floor
    Absolute,
    /// Percentage of position value floor
    Percentage,
}

/// Reason for exiting a position
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExitReason {
    /// Time threshold before resolution
    TimeThreshold {
        time_remaining_secs: i64,
        threshold_secs: u64,
    },
    /// P&L floor breached
    PnlFloor {
        unrealized_pnl: Decimal,
        floor: Decimal,
        floor_type: PnlFloorType,
    },
    /// Market is resolving or closed
    MarketResolved,
    /// Manual exit request
    Manual,
}

impl std::fmt::Display for ExitReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ExitReason::TimeThreshold {
                time_remaining_secs,
                threshold_secs,
            } => write!(
                f,
                "Time threshold ({}s remaining, threshold {}s)",
                time_remaining_secs, threshold_secs
            ),
            ExitReason::PnlFloor {
                unrealized_pnl,
                floor,
                floor_type,
            } => write!(
                f,
                "P&L floor ({:?}: {} vs {})",
                floor_type, unrealized_pnl, floor
            ),
            ExitReason::MarketResolved => write!(f, "Market resolved"),
            ExitReason::Manual => write!(f, "Manual exit"),
        }
    }
}

/// Market-specific override configuration for resolution exit
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketExitOverride {
    /// Market condition ID
    pub market_id: MarketId,
    /// Override exit time threshold (in seconds before resolution)
    pub exit_before_secs: Option<u64>,
    /// Override order type for this market
    pub order_type: Option<ExitOrderType>,
    /// Override P&L floor for this market
    pub pnl_floor_usd: Option<Decimal>,
}

/// Configuration for resolution-based exit strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResolutionExitConfig {
    /// Whether the strategy is enabled
    pub enabled: bool,
    /// Default time before resolution to exit (in seconds)
    pub default_exit_before_secs: u64,
    /// Default order type for exits
    pub exit_order_type: ExitOrderType,
    /// Maximum slippage allowed for FOK orders
    pub max_slippage: Decimal,
    /// Absolute P&L floor in USD (exit if unrealized PnL below this)
    pub pnl_floor_usd: Option<Decimal>,
    /// Percentage P&L floor (exit if unrealized PnL % below this)
    pub pnl_floor_pct: Option<Decimal>,
    /// Markets to hold through resolution (no auto-exit)
    #[serde(default)]
    pub hold_through_markets: Vec<String>,
    /// Market-specific override configurations
    #[serde(default)]
    pub market_overrides: Vec<MarketExitOverride>,
    /// Whether to log exit decisions
    pub log_exits: bool,
}

impl Default for ResolutionExitConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            default_exit_before_secs: 3600, // 1 hour
            exit_order_type: ExitOrderType::default(),
            max_slippage: Decimal::new(2, 2),           // 0.02 (2%)
            pnl_floor_usd: Some(Decimal::new(-100, 0)), // -$100
            pnl_floor_pct: None,
            hold_through_markets: Vec::new(),
            market_overrides: Vec::new(),
            log_exits: true,
        }
    }
}

impl ResolutionExitConfig {
    /// Check if a market should be held through resolution
    pub fn should_hold_through(&self, market_id: &str) -> bool {
        self.hold_through_markets
            .iter()
            .any(|m| m == market_id || market_id.contains(m))
    }

    /// Get the exit threshold for a market (in seconds before resolution)
    pub fn get_exit_before_secs(&self, market_id: &str) -> u64 {
        if let Some(override_config) = self
            .market_overrides
            .iter()
            .find(|o| o.market_id == market_id)
        {
            if let Some(secs) = override_config.exit_before_secs {
                return secs;
            }
        }
        self.default_exit_before_secs
    }

    /// Check if should exit based on time remaining
    pub fn should_exit_on_time(&self, market_id: &str, time_remaining_secs: i64) -> bool {
        let threshold = self.get_exit_before_secs(market_id) as i64;
        time_remaining_secs <= threshold && time_remaining_secs > 0
    }
}

/// Tracked position for resolution exit monitoring
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TrackedPosition {
    /// Market condition ID
    pub market_id: MarketId,
    /// Token ID being held
    pub token_id: TokenId,
    /// Position size in contracts
    pub size: Decimal,
    /// Average entry price
    pub avg_price: Decimal,
    /// Current unrealized P&L
    pub unrealized_pnl: Decimal,
    /// Market end date (resolution time)
    pub end_date: Option<chrono::DateTime<chrono::Utc>>,
    /// Whether an exit signal has been generated
    pub exit_signal_generated: bool,
    /// Reason for exit (if exit signal generated)
    pub exit_reason: Option<ExitReason>,
    /// Whether to hold through resolution
    pub hold_through: bool,
}

impl TrackedPosition {
    /// Calculate time remaining until resolution
    pub fn time_remaining(&self) -> Option<chrono::Duration> {
        self.end_date.map(|end| end - chrono::Utc::now())
    }

    /// Get time remaining in seconds
    pub fn time_remaining_secs(&self) -> Option<i64> {
        self.time_remaining().map(|d| d.num_seconds())
    }

    /// Calculate current position value
    pub fn position_value(&self) -> Decimal {
        self.size * self.avg_price
    }
}

/// Policy configuration for order management
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ManagementPolicyConfig {
    /// Price drift threshold in basis points before replacing
    pub price_drift_threshold_bps: Decimal,
    /// Minimum interval between replacements in milliseconds
    pub min_replace_interval_ms: u64,
    /// Maximum number of replacements per order
    pub max_replacements: u32,
    /// Whether to chase prices when they move
    pub chase_enabled: bool,
    /// Aggression factor for chasing (0.0-1.0)
    pub chase_aggression: f64,
}

impl Default for ManagementPolicyConfig {
    fn default() -> Self {
        Self {
            price_drift_threshold_bps: Decimal::new(50, 0), // 50 bps
            min_replace_interval_ms: 1000,
            max_replacements: 5,
            chase_enabled: true,
            chase_aggression: 0.5,
        }
    }
}

/// Configuration for automatic order management
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderManagementConfig {
    /// Whether order management is enabled
    pub enabled: bool,
    /// How often to check orders for price drift (in milliseconds)
    pub check_interval_ms: u64,
    /// Default policy for order management
    #[serde(default)]
    pub default_policy: ManagementPolicyConfig,
}

impl Default for OrderManagementConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            check_interval_ms: 1000,
            default_policy: ManagementPolicyConfig::default(),
        }
    }
}

/// Connection warmup and keep-alive configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionConfig {
    // WebSocket settings
    /// Ping interval in milliseconds (more aggressive than default 30s)
    #[serde(default = "default_ws_ping_interval_ms")]
    pub ws_ping_interval_ms: u64,
    /// Pong timeout in milliseconds before considering connection dead
    #[serde(default = "default_ws_pong_timeout_ms")]
    pub ws_pong_timeout_ms: u64,
    /// Initial reconnect delay in milliseconds
    #[serde(default = "default_ws_initial_reconnect_delay_ms")]
    pub ws_initial_reconnect_delay_ms: u64,
    /// Maximum reconnect delay in milliseconds
    #[serde(default = "default_ws_max_reconnect_delay_ms")]
    pub ws_max_reconnect_delay_ms: u64,
    /// Backoff multiplier for exponential backoff
    #[serde(default = "default_ws_backoff_multiplier")]
    pub ws_backoff_multiplier: f64,
    /// Jitter factor to prevent thundering herd (0.0 to 1.0)
    #[serde(default = "default_ws_jitter_factor")]
    pub ws_jitter_factor: f64,

    // HTTP pool settings
    /// Maximum idle connections per host
    #[serde(default = "default_http_max_idle_per_host")]
    pub http_max_idle_per_host: usize,
    /// How long to keep idle connections (seconds)
    #[serde(default = "default_http_idle_timeout_secs")]
    pub http_idle_timeout_secs: u64,
    /// Connection timeout (seconds)
    #[serde(default = "default_http_connect_timeout_secs")]
    pub http_connect_timeout_secs: u64,
    /// TCP keepalive interval (seconds)
    #[serde(default = "default_http_tcp_keepalive_secs")]
    pub http_tcp_keepalive_secs: u64,
    /// Request timeout (seconds)
    #[serde(default = "default_http_request_timeout_secs")]
    pub http_request_timeout_secs: u64,

    /// Warmup endpoints (establish connections on startup)
    #[serde(default)]
    pub warmup_urls: Vec<String>,
}

fn default_ws_ping_interval_ms() -> u64 { 15000 }
fn default_ws_pong_timeout_ms() -> u64 { 5000 }
fn default_ws_initial_reconnect_delay_ms() -> u64 { 100 }
fn default_ws_max_reconnect_delay_ms() -> u64 { 30000 }
fn default_ws_backoff_multiplier() -> f64 { 2.0 }
fn default_ws_jitter_factor() -> f64 { 0.1 }
fn default_http_max_idle_per_host() -> usize { 10 }
fn default_http_idle_timeout_secs() -> u64 { 90 }
fn default_http_connect_timeout_secs() -> u64 { 5 }
fn default_http_tcp_keepalive_secs() -> u64 { 60 }
fn default_http_request_timeout_secs() -> u64 { 30 }

impl Default for ConnectionConfig {
    fn default() -> Self {
        Self {
            ws_ping_interval_ms: default_ws_ping_interval_ms(),
            ws_pong_timeout_ms: default_ws_pong_timeout_ms(),
            ws_initial_reconnect_delay_ms: default_ws_initial_reconnect_delay_ms(),
            ws_max_reconnect_delay_ms: default_ws_max_reconnect_delay_ms(),
            ws_backoff_multiplier: default_ws_backoff_multiplier(),
            ws_jitter_factor: default_ws_jitter_factor(),
            http_max_idle_per_host: default_http_max_idle_per_host(),
            http_idle_timeout_secs: default_http_idle_timeout_secs(),
            http_connect_timeout_secs: default_http_connect_timeout_secs(),
            http_tcp_keepalive_secs: default_http_tcp_keepalive_secs(),
            http_request_timeout_secs: default_http_request_timeout_secs(),
            warmup_urls: vec![
                "https://clob.polymarket.com/".to_string(),
                "https://gamma-api.polymarket.com/".to_string(),
            ],
        }
    }
}

/// Configuration for the volume monitor used in participation rate adaptation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VolumeMonitorConfig {
    /// How far back to look for volume history (default: 3600 seconds = 1 hour)
    pub history_window_secs: u64,
    /// Granularity of volume observations (default: 60 seconds)
    pub observation_interval_secs: u64,
    /// Exponential moving average smoothing factor (default: 0.2)
    /// Higher values give more weight to recent observations
    pub smoothing_factor: Decimal,
}

impl Default for VolumeMonitorConfig {
    fn default() -> Self {
        Self {
            history_window_secs: 3600,
            observation_interval_secs: 60,
            smoothing_factor: Decimal::new(2, 1), // 0.2
        }
    }
}

/// Configuration for adaptive participation rate calculation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ParticipationConfig {
    /// Base participation rate (default: 0.10 = 10%)
    pub base_rate: Decimal,
    /// Minimum participation rate floor (default: 0.02 = 2%)
    pub min_rate: Decimal,
    /// Maximum participation rate ceiling (default: 0.25 = 25%)
    pub max_rate: Decimal,
    /// How aggressively to scale with volume (default: 0.5)
    /// Higher values make participation more responsive to volume changes
    pub volume_scaling_factor: Decimal,
    /// Additional participation boost for urgent orders (default: 0.05 = 5%)
    pub urgency_boost: Decimal,
    /// Boost participation in final 20% of execution window (default: 1.3 = 30% boost)
    pub time_pressure_boost: Decimal,
    /// Threshold for time pressure (remaining time percentage below which boost applies)
    pub time_pressure_threshold: Decimal,
}

impl Default for ParticipationConfig {
    fn default() -> Self {
        Self {
            base_rate: Decimal::new(1, 1),            // 0.10 = 10%
            min_rate: Decimal::new(2, 2),             // 0.02 = 2%
            max_rate: Decimal::new(25, 2),            // 0.25 = 25%
            volume_scaling_factor: Decimal::new(5, 1), // 0.5
            urgency_boost: Decimal::new(5, 2),        // 0.05 = 5%
            time_pressure_boost: Decimal::new(13, 1), // 1.3 = 30% boost
            time_pressure_threshold: Decimal::new(2, 1), // 0.2 = 20%
        }
    }
}

/// Operating mode for the RL execution agent
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum RlExecutionMode {
    /// Training mode - higher exploration, learning enabled
    #[default]
    Training,
    /// Production mode - low exploration, learning enabled
    Production,
    /// Evaluation mode - no exploration, no learning
    Evaluation,
}

/// Configuration for RL-based execution timing optimization
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RlExecutionConfig {
    /// Whether RL execution enhancement is enabled
    pub enabled: bool,
    /// Operating mode
    pub mode: RlExecutionMode,
    /// Learning rate (alpha) - how quickly to update Q-values
    pub alpha: f64,
    /// Discount factor (gamma) - importance of future rewards
    pub gamma: f64,
    /// Initial exploration rate (epsilon)
    pub epsilon: f64,
    /// Minimum exploration rate
    pub epsilon_min: f64,
    /// Exploration decay rate per episode
    pub epsilon_decay: f64,
    /// Experience replay buffer capacity
    pub replay_buffer_capacity: usize,
    /// Batch size for replay buffer sampling
    pub replay_batch_size: usize,
    /// How often to perform batch updates (in steps)
    pub update_frequency: usize,
    /// Decision interval in milliseconds
    pub decision_interval_ms: u64,
    /// Minimum order size per decision
    pub min_order_size: Decimal,
    /// Maximum time to wait without progress (seconds)
    pub max_wait_secs: u64,
    /// Path to save/load the RL model
    pub model_path: String,
    /// How often to save the model (seconds)
    pub save_interval_secs: u64,
    /// Reward weight for fill rate
    pub reward_fill_weight: f64,
    /// Reward weight for slippage penalty
    pub reward_slippage_weight: f64,
    /// Reward weight for time penalty
    pub reward_time_weight: f64,
    /// Reward weight for market impact penalty
    pub reward_impact_weight: f64,
}

impl Default for RlExecutionConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            mode: RlExecutionMode::Training,
            alpha: 0.1,
            gamma: 0.99,
            epsilon: 0.3,
            epsilon_min: 0.05,
            epsilon_decay: 0.995,
            replay_buffer_capacity: 10000,
            replay_batch_size: 32,
            update_frequency: 10,
            decision_interval_ms: 1000,
            min_order_size: Decimal::new(10, 0),
            max_wait_secs: 30,
            model_path: "data/rl_execution_model.json".to_string(),
            save_interval_secs: 300,
            reward_fill_weight: 10.0,
            reward_slippage_weight: 100.0,
            reward_time_weight: 50.0,
            reward_impact_weight: 50.0,
        }
    }
}
