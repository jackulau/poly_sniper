use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use std::fmt;

/// Unique identifier for a market (Polymarket condition ID)
pub type MarketId = String;

/// Unique identifier for a token (YES/NO outcome token)
pub type TokenId = String;

/// Unique identifier for an order
pub type OrderId = String;

/// Side of a trade
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "UPPERCASE")]
pub enum Side {
    Buy,
    Sell,
}

impl fmt::Display for Side {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Side::Buy => write!(f, "BUY"),
            Side::Sell => write!(f, "SELL"),
        }
    }
}

/// Order type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "UPPERCASE")]
pub enum OrderType {
    /// Good-til-cancelled limit order
    Gtc,
    /// Fill-or-kill market order
    Fok,
    /// Good-til-date limit order
    Gtd,
}

/// Outcome type for a market
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Outcome {
    Yes,
    No,
}

impl fmt::Display for Outcome {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Outcome::Yes => write!(f, "YES"),
            Outcome::No => write!(f, "NO"),
        }
    }
}

/// Priority level for trade signals
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum Priority {
    Low = 0,
    #[default]
    Normal = 1,
    High = 2,
    Critical = 3,
}

/// Market metadata from Gamma API
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Market {
    /// Condition ID (unique market identifier)
    pub condition_id: MarketId,
    /// Human-readable question
    pub question: String,
    /// Market description
    pub description: Option<String>,
    /// Market category/tags
    pub tags: Vec<String>,
    /// YES token ID
    pub yes_token_id: TokenId,
    /// NO token ID
    pub no_token_id: TokenId,
    /// When the market was created
    pub created_at: DateTime<Utc>,
    /// When the market ends (resolution time)
    pub end_date: Option<DateTime<Utc>>,
    /// Whether the market is active for trading
    pub active: bool,
    /// Whether the market is closed
    pub closed: bool,
    /// Total volume in USD
    pub volume: Decimal,
    /// Total liquidity in USD
    pub liquidity: Decimal,
}

/// A single price level in the orderbook
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PriceLevel {
    pub price: Decimal,
    pub size: Decimal,
}

/// Orderbook snapshot for a token
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Orderbook {
    pub token_id: TokenId,
    pub market_id: MarketId,
    pub bids: Vec<PriceLevel>,
    pub asks: Vec<PriceLevel>,
    pub timestamp: DateTime<Utc>,
}

impl Orderbook {
    /// Get the best bid price
    pub fn best_bid(&self) -> Option<Decimal> {
        self.bids.first().map(|l| l.price)
    }

    /// Get the best ask price
    pub fn best_ask(&self) -> Option<Decimal> {
        self.asks.first().map(|l| l.price)
    }

    /// Get the mid price
    pub fn mid_price(&self) -> Option<Decimal> {
        match (self.best_bid(), self.best_ask()) {
            (Some(bid), Some(ask)) => Some((bid + ask) / Decimal::TWO),
            (Some(bid), None) => Some(bid),
            (None, Some(ask)) => Some(ask),
            (None, None) => None,
        }
    }

    /// Get the spread
    pub fn spread(&self) -> Option<Decimal> {
        match (self.best_bid(), self.best_ask()) {
            (Some(bid), Some(ask)) => Some(ask - bid),
            _ => None,
        }
    }
}

/// Trade signal generated by a strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradeSignal {
    /// Unique signal ID
    pub id: String,
    /// Strategy that generated this signal
    pub strategy_id: String,
    /// Market to trade
    pub market_id: MarketId,
    /// Token to trade
    pub token_id: TokenId,
    /// Outcome being traded
    pub outcome: Outcome,
    /// Buy or sell
    pub side: Side,
    /// Target price (for limit orders)
    pub price: Option<Decimal>,
    /// Size in contracts
    pub size: Decimal,
    /// Size in USD
    pub size_usd: Decimal,
    /// Order type
    pub order_type: OrderType,
    /// Priority level
    pub priority: Priority,
    /// When the signal was generated
    pub timestamp: DateTime<Utc>,
    /// Reason/explanation for the signal
    pub reason: String,
    /// Additional metadata
    pub metadata: serde_json::Value,
}

/// Order to be submitted to CLOB
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Order {
    pub id: OrderId,
    pub market_id: MarketId,
    pub token_id: TokenId,
    pub side: Side,
    pub price: Decimal,
    pub size: Decimal,
    pub order_type: OrderType,
    pub signal_id: String,
    pub created_at: DateTime<Utc>,
}

/// Order status from CLOB
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum OrderStatus {
    Live,
    Matched,
    Cancelled,
    Expired,
}

/// Position in a market
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Position {
    pub market_id: MarketId,
    pub token_id: TokenId,
    pub outcome: Outcome,
    pub size: Decimal,
    pub avg_price: Decimal,
    pub realized_pnl: Decimal,
    pub unrealized_pnl: Decimal,
    pub updated_at: DateTime<Utc>,
}

/// Price snapshot for a market
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PriceSnapshot {
    pub market_id: MarketId,
    pub token_id: TokenId,
    pub price: Decimal,
    pub timestamp: DateTime<Utc>,
}

/// Configuration for endpoints
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EndpointConfig {
    pub clob_rest: String,
    pub clob_ws: String,
    pub gamma_api: String,
}

impl Default for EndpointConfig {
    fn default() -> Self {
        Self {
            clob_rest: "https://clob.polymarket.com".to_string(),
            clob_ws: "wss://ws-subscriptions-clob.polymarket.com/ws/".to_string(),
            gamma_api: "https://gamma-api.polymarket.com".to_string(),
        }
    }
}

/// Authentication configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthConfig {
    /// Environment variable containing the private key
    pub private_key_env: String,
    /// Signature type (0 = EOA, 1 = Poly Proxy, 2 = Poly Gnosis Safe)
    pub signature_type: u8,
}

impl Default for AuthConfig {
    fn default() -> Self {
        Self {
            private_key_env: "POLYMARKET_PRIVATE_KEY".to_string(),
            signature_type: 0,
        }
    }
}

/// Correlation tracking configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CorrelationConfig {
    /// Whether correlation-aware limits are enabled
    pub enabled: bool,
    /// Minimum correlation threshold to group markets (e.g., 0.7)
    pub correlation_threshold: Decimal,
    /// Time window in seconds for correlation calculation
    pub window_secs: u64,
    /// Maximum total exposure across correlated markets in USD
    pub max_correlated_exposure_usd: Decimal,
    /// Manual correlation groups (market slugs)
    #[serde(default)]
    pub groups: Vec<CorrelationGroupConfig>,
}

impl Default for CorrelationConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            correlation_threshold: Decimal::new(7, 1), // 0.7
            window_secs: 3600,                         // 1 hour
            max_correlated_exposure_usd: Decimal::new(3000, 0),
            groups: Vec::new(),
        }
    }
}

/// Manual correlation group configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CorrelationGroupConfig {
    /// Group name/identifier
    pub name: String,
    /// Market IDs or slug patterns in this group
    pub markets: Vec<String>,
}

/// Risk configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RiskConfig {
    pub max_position_size_usd: Decimal,
    pub max_order_size_usd: Decimal,
    pub daily_loss_limit_usd: Decimal,
    pub circuit_breaker_loss_usd: Decimal,
    pub max_orders_per_minute: u32,
    /// Correlation-aware position limit configuration
    #[serde(default)]
    pub correlation: CorrelationConfig,
}

impl Default for RiskConfig {
    fn default() -> Self {
        Self {
            max_position_size_usd: Decimal::new(5000, 0),
            max_order_size_usd: Decimal::new(500, 0),
            daily_loss_limit_usd: Decimal::new(500, 0),
            circuit_breaker_loss_usd: Decimal::new(300, 0),
            max_orders_per_minute: 60,
            correlation: CorrelationConfig::default(),
        }
    }
}

/// Adaptive order sizing configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AdaptiveSizingConfig {
    /// Whether adaptive sizing is enabled
    pub enabled: bool,
    /// Maximum acceptable price impact in basis points
    pub max_market_impact_bps: Decimal,
    /// Minimum ratio of order size to available depth (0.0 to 1.0)
    pub min_liquidity_ratio: Decimal,
    /// Factor to reduce size when book is thin (0.0 to 1.0)
    pub size_reduction_factor: Decimal,
}

impl Default for AdaptiveSizingConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            max_market_impact_bps: Decimal::new(50, 0),    // 50 bps
            min_liquidity_ratio: Decimal::new(1, 1),       // 0.1 (10%)
            size_reduction_factor: Decimal::new(8, 1),     // 0.8 (reduce by 20%)
        }
    }
}

/// Execution configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionConfig {
    pub dry_run: bool,
    pub max_retries: u32,
    pub retry_delay_ms: u64,
    #[serde(default)]
    pub adaptive_sizing: AdaptiveSizingConfig,
}

impl Default for ExecutionConfig {
    fn default() -> Self {
        Self {
            dry_run: true,
            max_retries: 3,
            retry_delay_ms: 100,
            adaptive_sizing: AdaptiveSizingConfig::default(),
        }
    }
}

/// Persistence configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PersistenceConfig {
    pub enabled: bool,
    pub db_path: String,
    pub price_snapshot_interval_secs: u64,
    pub max_price_snapshots: i64,
}

impl Default for PersistenceConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            db_path: "data/polysniper.db".to_string(),
            price_snapshot_interval_secs: 60,
            max_price_snapshots: 10000,
        }
    }
}

/// Metrics configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetricsConfig {
    pub enabled: bool,
    pub port: u16,
    pub collection_interval_secs: u64,
}

impl Default for MetricsConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            port: 9090,
            collection_interval_secs: 60,
        }
    }
}

/// Health check server configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthConfig {
    pub enabled: bool,
    pub bind_address: String,
}

impl Default for HealthConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            bind_address: "127.0.0.1:8080".to_string(),
        }
    }
}

/// Slack alerting configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SlackAlertConfig {
    pub enabled: bool,
    pub webhook_url: String,
    pub channel: Option<String>,
    pub username: Option<String>,
    pub icon_emoji: Option<String>,
}

impl Default for SlackAlertConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            webhook_url: String::new(),
            channel: Some("#polysniper-alerts".to_string()),
            username: Some("Polysniper".to_string()),
            icon_emoji: Some(":chart_with_upwards_trend:".to_string()),
        }
    }
}

/// Telegram alerting configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TelegramAlertConfig {
    pub enabled: bool,
    pub bot_token: String,
    pub chat_id: String,
    pub parse_mode: Option<String>,
}

impl Default for TelegramAlertConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            bot_token: String::new(),
            chat_id: String::new(),
            parse_mode: Some("HTML".to_string()),
        }
    }
}

/// Discord webhook configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DiscordConfig {
    pub enabled: bool,
    /// Webhook URL (recommended to use DISCORD_WEBHOOK_URL env var instead)
    pub webhook_url: Option<String>,
    pub notify_on_trade: bool,
    pub notify_on_error: bool,
    pub notify_on_risk_events: bool,
    pub notify_on_connection_status: bool,
    pub dry_run: bool,
    pub rate_limit_per_minute: u32,
}

impl Default for DiscordConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            webhook_url: None,
            notify_on_trade: true,
            notify_on_error: true,
            notify_on_risk_events: true,
            notify_on_connection_status: false,
            dry_run: false,
            rate_limit_per_minute: 30,
        }
    }
}

/// Alerting configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertingConfig {
    pub enabled: bool,
    pub min_level: String,
    pub rate_limit_seconds: u64,
    pub slack: SlackAlertConfig,
    pub telegram: TelegramAlertConfig,
}

/// Fill management configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FillManagementConfig {
    pub enabled: bool,
    pub auto_resubmit: bool,
    pub min_resubmit_size: Decimal,
    pub poll_interval_ms: u64,
    pub max_resubmit_attempts: u32,
}

impl Default for FillManagementConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            auto_resubmit: false,
            min_resubmit_size: Decimal::new(10, 0),
            poll_interval_ms: 1000,
            max_resubmit_attempts: 3,
        }
    }
}

impl Default for AlertingConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            min_level: "warning".to_string(),
            rate_limit_seconds: 60,
            slack: SlackAlertConfig::default(),
            telegram: TelegramAlertConfig::default(),
        }
    }
}

/// Main application configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[derive(Default)]
pub struct AppConfig {
    #[serde(default)]
    pub endpoints: EndpointConfig,
    #[serde(default)]
    pub auth: AuthConfig,
    #[serde(default)]
    pub risk: RiskConfig,
    #[serde(default)]
    pub execution: ExecutionConfig,
    #[serde(default)]
    pub persistence: PersistenceConfig,
    #[serde(default)]
    pub metrics: MetricsConfig,
    #[serde(default)]
    pub alerting: AlertingConfig,
}
