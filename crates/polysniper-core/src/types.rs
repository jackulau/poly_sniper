use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use std::fmt;

/// Unique identifier for a market (Polymarket condition ID)
pub type MarketId = String;

/// Unique identifier for a token (YES/NO outcome token)
pub type TokenId = String;

/// Unique identifier for an order
pub type OrderId = String;

/// Side of a trade
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "UPPERCASE")]
pub enum Side {
    Buy,
    Sell,
}

impl fmt::Display for Side {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Side::Buy => write!(f, "BUY"),
            Side::Sell => write!(f, "SELL"),
        }
    }
}

/// Order type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "UPPERCASE")]
pub enum OrderType {
    /// Good-til-cancelled limit order
    Gtc,
    /// Fill-or-kill market order
    Fok,
    /// Good-til-date limit order
    Gtd,
}

/// Outcome type for a market
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Outcome {
    Yes,
    No,
}

impl fmt::Display for Outcome {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Outcome::Yes => write!(f, "YES"),
            Outcome::No => write!(f, "NO"),
        }
    }
}

/// Priority level for trade signals
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum Priority {
    Low = 0,
    Normal = 1,
    High = 2,
    Critical = 3,
}

impl Default for Priority {
    fn default() -> Self {
        Priority::Normal
    }
}

/// Market metadata from Gamma API
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Market {
    /// Condition ID (unique market identifier)
    pub condition_id: MarketId,
    /// Human-readable question
    pub question: String,
    /// Market description
    pub description: Option<String>,
    /// Market category/tags
    pub tags: Vec<String>,
    /// YES token ID
    pub yes_token_id: TokenId,
    /// NO token ID
    pub no_token_id: TokenId,
    /// When the market was created
    pub created_at: DateTime<Utc>,
    /// When the market ends (resolution time)
    pub end_date: Option<DateTime<Utc>>,
    /// Whether the market is active for trading
    pub active: bool,
    /// Whether the market is closed
    pub closed: bool,
    /// Total volume in USD
    pub volume: Decimal,
    /// Total liquidity in USD
    pub liquidity: Decimal,
}

/// A single price level in the orderbook
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PriceLevel {
    pub price: Decimal,
    pub size: Decimal,
}

/// Orderbook snapshot for a token
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Orderbook {
    pub token_id: TokenId,
    pub market_id: MarketId,
    pub bids: Vec<PriceLevel>,
    pub asks: Vec<PriceLevel>,
    pub timestamp: DateTime<Utc>,
}

impl Orderbook {
    /// Get the best bid price
    pub fn best_bid(&self) -> Option<Decimal> {
        self.bids.first().map(|l| l.price)
    }

    /// Get the best ask price
    pub fn best_ask(&self) -> Option<Decimal> {
        self.asks.first().map(|l| l.price)
    }

    /// Get the mid price
    pub fn mid_price(&self) -> Option<Decimal> {
        match (self.best_bid(), self.best_ask()) {
            (Some(bid), Some(ask)) => Some((bid + ask) / Decimal::TWO),
            (Some(bid), None) => Some(bid),
            (None, Some(ask)) => Some(ask),
            (None, None) => None,
        }
    }

    /// Get the spread
    pub fn spread(&self) -> Option<Decimal> {
        match (self.best_bid(), self.best_ask()) {
            (Some(bid), Some(ask)) => Some(ask - bid),
            _ => None,
        }
    }
}

/// Trade signal generated by a strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradeSignal {
    /// Unique signal ID
    pub id: String,
    /// Strategy that generated this signal
    pub strategy_id: String,
    /// Market to trade
    pub market_id: MarketId,
    /// Token to trade
    pub token_id: TokenId,
    /// Outcome being traded
    pub outcome: Outcome,
    /// Buy or sell
    pub side: Side,
    /// Target price (for limit orders)
    pub price: Option<Decimal>,
    /// Size in contracts
    pub size: Decimal,
    /// Size in USD
    pub size_usd: Decimal,
    /// Order type
    pub order_type: OrderType,
    /// Priority level
    pub priority: Priority,
    /// When the signal was generated
    pub timestamp: DateTime<Utc>,
    /// Reason/explanation for the signal
    pub reason: String,
    /// Additional metadata
    pub metadata: serde_json::Value,
}

/// Order to be submitted to CLOB
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Order {
    pub id: OrderId,
    pub market_id: MarketId,
    pub token_id: TokenId,
    pub side: Side,
    pub price: Decimal,
    pub size: Decimal,
    pub order_type: OrderType,
    pub signal_id: String,
    pub created_at: DateTime<Utc>,
}

/// Order status from CLOB
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum OrderStatus {
    Live,
    Matched,
    Cancelled,
    Expired,
}

/// Position in a market
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Position {
    pub market_id: MarketId,
    pub token_id: TokenId,
    pub outcome: Outcome,
    pub size: Decimal,
    pub avg_price: Decimal,
    pub realized_pnl: Decimal,
    pub unrealized_pnl: Decimal,
    pub updated_at: DateTime<Utc>,
}

/// Price snapshot for a market
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PriceSnapshot {
    pub market_id: MarketId,
    pub token_id: TokenId,
    pub price: Decimal,
    pub timestamp: DateTime<Utc>,
}

/// Configuration for endpoints
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EndpointConfig {
    pub clob_rest: String,
    pub clob_ws: String,
    pub gamma_api: String,
}

impl Default for EndpointConfig {
    fn default() -> Self {
        Self {
            clob_rest: "https://clob.polymarket.com".to_string(),
            clob_ws: "wss://ws-subscriptions-clob.polymarket.com/ws/".to_string(),
            gamma_api: "https://gamma-api.polymarket.com".to_string(),
        }
    }
}

/// Authentication configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthConfig {
    /// Environment variable containing the private key
    pub private_key_env: String,
    /// Signature type (0 = EOA, 1 = Poly Proxy, 2 = Poly Gnosis Safe)
    pub signature_type: u8,
}

impl Default for AuthConfig {
    fn default() -> Self {
        Self {
            private_key_env: "POLYMARKET_PRIVATE_KEY".to_string(),
            signature_type: 0,
        }
    }
}

/// Volatility-adjusted position sizing configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VolatilityConfig {
    /// Whether volatility-based sizing is enabled
    pub enabled: bool,
    /// Rolling window in seconds for volatility calculation
    pub window_secs: u64,
    /// Reference/baseline volatility percentage (standard deviation)
    pub base_volatility_pct: Decimal,
    /// Minimum size multiplier floor (e.g., 0.25 = 25% of normal size)
    pub min_size_multiplier: Decimal,
    /// Maximum size multiplier ceiling (e.g., 1.5 = 150% of normal size)
    pub max_size_multiplier: Decimal,
}

impl Default for VolatilityConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            window_secs: 300,
            base_volatility_pct: Decimal::new(5, 0),  // 5%
            min_size_multiplier: Decimal::new(25, 2), // 0.25
            max_size_multiplier: Decimal::new(15, 1), // 1.5
        }
    }
}

/// Risk configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RiskConfig {
    pub max_position_size_usd: Decimal,
    pub max_order_size_usd: Decimal,
    pub daily_loss_limit_usd: Decimal,
    pub circuit_breaker_loss_usd: Decimal,
    pub max_orders_per_minute: u32,
    /// Volatility-adjusted position sizing config
    #[serde(default)]
    pub volatility: VolatilityConfig,
}

impl Default for RiskConfig {
    fn default() -> Self {
        Self {
            max_position_size_usd: Decimal::new(5000, 0),
            max_order_size_usd: Decimal::new(500, 0),
            daily_loss_limit_usd: Decimal::new(500, 0),
            circuit_breaker_loss_usd: Decimal::new(300, 0),
            max_orders_per_minute: 60,
            volatility: VolatilityConfig::default(),
        }
    }
}

/// Execution configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionConfig {
    pub dry_run: bool,
    pub max_retries: u32,
    pub retry_delay_ms: u64,
}

impl Default for ExecutionConfig {
    fn default() -> Self {
        Self {
            dry_run: true,
            max_retries: 3,
            retry_delay_ms: 100,
        }
    }
}

/// Persistence configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PersistenceConfig {
    pub enabled: bool,
    pub db_path: String,
    pub price_snapshot_interval_secs: u64,
    pub max_price_snapshots: i64,
}

impl Default for PersistenceConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            db_path: "data/polysniper.db".to_string(),
            price_snapshot_interval_secs: 60,
            max_price_snapshots: 10000,
        }
    }
}

/// Metrics configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetricsConfig {
    pub enabled: bool,
    pub port: u16,
    pub collection_interval_secs: u64,
}

impl Default for MetricsConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            port: 9090,
            collection_interval_secs: 60,
        }
    }
}

/// Slack alerting configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SlackAlertConfig {
    pub enabled: bool,
    pub webhook_url: String,
    pub channel: Option<String>,
    pub username: Option<String>,
    pub icon_emoji: Option<String>,
}

impl Default for SlackAlertConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            webhook_url: String::new(),
            channel: Some("#polysniper-alerts".to_string()),
            username: Some("Polysniper".to_string()),
            icon_emoji: Some(":chart_with_upwards_trend:".to_string()),
        }
    }
}

/// Telegram alerting configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TelegramAlertConfig {
    pub enabled: bool,
    pub bot_token: String,
    pub chat_id: String,
    pub parse_mode: Option<String>,
}

impl Default for TelegramAlertConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            bot_token: String::new(),
            chat_id: String::new(),
            parse_mode: Some("HTML".to_string()),
        }
    }
}

/// Alerting configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertingConfig {
    pub enabled: bool,
    pub min_level: String,
    pub rate_limit_seconds: u64,
    pub slack: SlackAlertConfig,
    pub telegram: TelegramAlertConfig,
}

impl Default for AlertingConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            min_level: "warning".to_string(),
            rate_limit_seconds: 60,
            slack: SlackAlertConfig::default(),
            telegram: TelegramAlertConfig::default(),
        }
    }
}

/// Main application configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppConfig {
    pub endpoints: EndpointConfig,
    pub auth: AuthConfig,
    pub risk: RiskConfig,
    pub execution: ExecutionConfig,
    #[serde(default)]
    pub persistence: PersistenceConfig,
    #[serde(default)]
    pub metrics: MetricsConfig,
    #[serde(default)]
    pub alerting: AlertingConfig,
}

impl Default for AppConfig {
    fn default() -> Self {
        Self {
            endpoints: EndpointConfig::default(),
            auth: AuthConfig::default(),
            risk: RiskConfig::default(),
            execution: ExecutionConfig::default(),
            persistence: PersistenceConfig::default(),
            metrics: MetricsConfig::default(),
            alerting: AlertingConfig::default(),
        }
    }
}
