# Polysniper Configuration

# Health check HTTP server
[health]
# Whether the health server is enabled
enabled = true
# Address and port to bind to
bind_address = "127.0.0.1:8080"

[endpoints]
clob_rest = "https://clob.polymarket.com"
clob_ws = "wss://ws-subscriptions-clob.polymarket.com/ws/"
gamma_api = "https://gamma-api.polymarket.com"

# Connection warmup and keep-alive settings
[connection]
# WebSocket settings
# Ping interval in milliseconds (more aggressive than default 30s)
ws_ping_interval_ms = 15000
# Pong timeout in milliseconds before considering connection dead
ws_pong_timeout_ms = 5000
# Initial reconnect delay in milliseconds
ws_initial_reconnect_delay_ms = 100
# Maximum reconnect delay in milliseconds
ws_max_reconnect_delay_ms = 30000
# Backoff multiplier for exponential backoff
ws_backoff_multiplier = 2.0
# Jitter factor to prevent thundering herd (0.0 to 1.0)
ws_jitter_factor = 0.1

# HTTP pool settings
# Maximum idle connections per host
http_max_idle_per_host = 10
# How long to keep idle connections (seconds)
http_idle_timeout_secs = 90
# Connection timeout (seconds)
http_connect_timeout_secs = 5
# TCP keepalive interval (seconds)
http_tcp_keepalive_secs = 60
# Request timeout (seconds)
http_request_timeout_secs = 30

# Warmup endpoints (establish connections on startup to reduce cold-start latency)
warmup_urls = [
    "https://clob.polymarket.com/",
    "https://gamma-api.polymarket.com/"
]

[auth]
# Environment variable containing the private key
private_key_env = "POLYMARKET_PRIVATE_KEY"
# Signature type: 0 = EOA wallet, 1 = Poly Proxy, 2 = Poly Gnosis Safe
signature_type = 0

[risk]
# Maximum position size per market in USD
max_position_size_usd = 5000
# Maximum single order size in USD
max_order_size_usd = 500
# Daily loss limit in USD (stops trading when reached)
daily_loss_limit_usd = 500
# Circuit breaker threshold (halts all trading)
circuit_breaker_loss_usd = 300
# Maximum orders per minute
max_orders_per_minute = 60

# Correlation-aware position limits
[risk.correlation]
# Whether correlation-aware limits are enabled
enabled = true
# Minimum correlation threshold to group markets dynamically
correlation_threshold = 0.7
# Time window in seconds for correlation calculation
window_secs = 3600
# Maximum total exposure across correlated markets in USD (base limit, adjusted by regime)
max_correlated_exposure_usd = 3000

# Correlation regime detection for dynamic limit adjustment
[risk.correlation.regime]
# Whether regime detection is enabled
enabled = true
# Short-term rolling window in seconds (5 minutes)
short_window_secs = 300
# Long-term rolling window in seconds (24 hours)
long_window_secs = 86400
# Threshold for elevated regime (50% above baseline triggers elevated)
elevated_threshold = 0.5
# Threshold for crisis regime (100% above baseline triggers crisis)
crisis_threshold = 1.0
# Exposure limit multiplier during normal regime
normal_limit_multiplier = 1.0
# Exposure limit multiplier during elevated regime (70% of base limit)
elevated_limit_multiplier = 0.7
# Exposure limit multiplier during crisis regime (40% of base limit)
crisis_limit_multiplier = 0.4
# Minimum samples required before regime detection activates
min_samples = 100
# Hysteresis factor to prevent regime flickering (10%)
hysteresis_factor = 0.1

# Volatility-adjusted position sizing
[risk.volatility]
# Whether volatility-based sizing is enabled
enabled = true
# Rolling window in seconds for volatility calculation
window_secs = 300
# Reference/baseline volatility percentage (positions sized normally at this level)
base_volatility_pct = 5.0
# Minimum size multiplier floor (e.g., 0.25 = 25% of normal size in extreme volatility)
min_size_multiplier = 0.25
# Maximum size multiplier ceiling (e.g., 1.5 = 150% of normal size in low volatility)
max_size_multiplier = 1.5

# Drawdown-triggered position scaling
# Progressively reduces position sizes as portfolio drawdown deepens
[risk.drawdown]
# Whether drawdown-based scaling is enabled
enabled = true
# Tier 1: 5% drawdown -> reduce to 75% size
tier_1_threshold_pct = 5.0
tier_1_multiplier = 0.75
# Tier 2: 10% drawdown -> reduce to 50% size
tier_2_threshold_pct = 10.0
tier_2_multiplier = 0.50
# Tier 3: 20% drawdown -> reduce to 25% size
tier_3_threshold_pct = 20.0
tier_3_multiplier = 0.25
# Maximum drawdown before minimum sizing
max_drawdown_pct = 30.0
# Minimum multiplier floor (10% of normal size)
min_multiplier = 0.10
# Recovery buffer: must recover by this % from drawdown before increasing sizes
# Prevents rapid oscillation during volatile recovery periods
recovery_buffer_pct = 2.0
# Kelly criterion position sizing
# Optimizes position sizes based on historical edge and win rate
[risk.kelly]
# Whether Kelly criterion sizing is enabled
enabled = true
# Fractional Kelly multiplier (0.25 = quarter-Kelly, 0.5 = half-Kelly, 1.0 = full Kelly)
# Half-Kelly is recommended for conservative sizing while still capturing most of the benefit
fraction = 0.5
# Number of recent trades to consider for edge calculation
window_size = 100
# Minimum number of trades required before Kelly sizing kicks in
# Uses base sizing (1.0 multiplier) until this threshold is met
min_trades = 20
# Maximum position multiplier (caps Kelly sizing to avoid over-betting on positive edge)
max_multiplier = 2.0
# Minimum position multiplier (ensures some position even with negative or zero edge)
min_multiplier = 0.25
# Value at Risk (VaR) and Conditional VaR (CVaR) configuration
[risk.var]
# Whether VaR-based risk limits are enabled
enabled = true
# VaR calculation method: "historical" or "parametric"
method = "historical"
# Confidence level for VaR (e.g., 0.95 for 95% VaR)
confidence_level = 0.95
# Number of days of historical data to use for calculation
lookback_days = 30
# Maximum allowed daily portfolio VaR in USD
max_portfolio_var_usd = 500
# Maximum position VaR contribution as percentage of total (e.g., 0.25 = 25%)
max_position_var_contribution_pct = 0.25
# Whether to use CVaR (Expected Shortfall) instead of VaR for limit enforcement
# CVaR is more conservative as it captures average tail losses
use_cvar_for_limits = false

[execution]
# Set to true to log orders without actually submitting
dry_run = true
# Number of retry attempts for failed orders
max_retries = 3
# Delay between retries in milliseconds
retry_delay_ms = 100

# Execution Algorithms (TWAP/VWAP) for large order execution
[execution.algorithms]
# Default algorithm for large orders: "twap" or "vwap"
default_algorithm = "twap"
# Minimum order size (USD) to trigger algorithmic execution
min_size_for_algo = 100

# TWAP (Time-Weighted Average Price) Configuration
[execution.algorithms.twap]
# Total execution window in seconds
total_duration_secs = 300
# Number of child order slices
num_slices = 10
# Add random jitter to timing to avoid pattern detection
randomize_timing = true
# Timing jitter as percentage (0.0-1.0)
timing_jitter_pct = 0.2
# Vary child order sizes randomly
randomize_size = true
# Size variation as percentage (0.0-1.0)
size_jitter_pct = 0.1
# Maximum participation rate (fraction of interval volume)
max_participation_rate = 0.1

# VWAP (Volume-Weighted Average Price) Configuration
[execution.algorithms.vwap]
# Total execution window in seconds
total_duration_secs = 300
# Number of child order slices
num_slices = 10
# Volume profile: "uniform", "front_loaded", "back_loaded", "u_shaped"
# For custom profiles, use separate config file
volume_profile = "uniform"
# Maximum participation rate
max_participation_rate = 0.1
# Adapt execution based on real-time observed volume
adaptive = false
# Add random jitter to timing
randomize_timing = true
# Timing jitter as percentage (0.0-1.0)
timing_jitter_pct = 0.15

# Phase 5: SQLite Persistence
[persistence]
# Whether persistence is enabled
enabled = true
# Path to SQLite database file
db_path = "data/polysniper.db"
# Price snapshot interval in seconds
price_snapshot_interval_secs = 60
# Maximum price snapshots to keep per token
max_price_snapshots = 10000

# Phase 6: Prometheus Metrics
[metrics]
# Whether metrics are enabled
enabled = true
# Port for metrics HTTP server (accessible at http://localhost:9090/metrics)
port = 9090
# Collection interval in seconds
collection_interval_secs = 60

# Phase 7: Alerting
[alerting]
# Whether alerting is enabled
enabled = true
# Minimum alert level to send (info, warning, critical)
min_level = "warning"
# Rate limit between duplicate alerts in seconds
rate_limit_seconds = 60

# Slack webhook configuration
[alerting.slack]
enabled = false
webhook_url = ""
channel = "#polysniper-alerts"
username = "Polysniper"
icon_emoji = ":chart_with_upwards_trend:"

# Telegram bot configuration
[alerting.telegram]
enabled = false
bot_token = ""
chat_id = ""
parse_mode = "HTML"

# Feed Ingestion for Sentiment Analysis
[feeds]
# Whether feed ingestion is enabled
enabled = false
# Global keywords to track across all sources
keywords = ["polymarket", "prediction market", "kalshi"]
# Maximum items to keep in deduplication cache
dedup_cache_size = 10000

# Twitter API configuration
[feeds.twitter]
enabled = false
# Environment variable containing the Twitter Bearer Token
bearer_token_env = "TWITTER_BEARER_TOKEN"
# Polling interval in seconds (min 60 to respect rate limits)
poll_interval_secs = 60
# Maximum results per query (max 100)
max_results = 100

# Twitter search queries to monitor
[[feeds.twitter.queries]]
query = "polymarket"
include_retweets = false

[[feeds.twitter.queries]]
query = "prediction market"
include_retweets = false

# RSS/Atom feed configuration
[feeds.rss]
enabled = false
# Polling interval in seconds
poll_interval_secs = 300
# Request timeout in seconds
timeout_secs = 30

# RSS feeds to monitor
# [[feeds.rss.feeds]]
# url = "https://example.com/feed.xml"
# name = "Example Feed"
# keywords = []  # Empty means all items

# Latency Optimization Settings
[latency]
# Whether latency optimizations are enabled
enabled = true

# Connection pool configuration for maintaining warm connections
[latency.connection_pool]
# Number of CLOB REST connections to maintain
clob_pool_size = 3
# Number of Polygon RPC connections to maintain
rpc_pool_size = 2
# Connection establishment timeout in milliseconds
connection_timeout_ms = 5000
# Per-request timeout in milliseconds
request_timeout_ms = 2000
# Health check interval in seconds
health_check_interval_secs = 30
# Route requests to the fastest responding connection
prefer_fastest = true

# WebSocket latency optimizations
[latency.websocket]
# Enable WebSocket compression (disabled by default as it adds CPU overhead)
enable_compression = false
# Enable TCP_NODELAY to disable Nagle's algorithm (reduces latency)
tcp_nodelay = true
# Receive buffer size in bytes
buffer_size = 65536
# High-priority token subscriptions (processed first)
priority_subscriptions = []

# Fast execution configuration
[latency.execution]
# Submit to multiple endpoints in parallel (first response wins)
parallel_submissions = true
# Pre-sign common order templates for faster submission
pre_sign_orders = true
# Batch small orders together (not recommended for latency-critical orders)
batch_small_orders = false
# Use speculative nonce to avoid nonce lookup latency
speculative_nonce = true
